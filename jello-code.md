When someone says that application code is like jello, they are often referring to the code's lack of stability and structure. It implies that the codebase is soft, flexible, and can easily change or shift in unpredictable ways.

Here are some characteristics associated with describing code as "like jello":

1. **Lack of Rigidity**: Jello is known for its lack of firmness and stability. Similarly, when code is compared to jello, it suggests that the codebase lacks a solid and well-defined structure. The code may be loosely organized, making it difficult to maintain and modify.

2. **Unpredictability**: Jello has a tendency to wobble or deform when touched. Similarly, code described as jello may exhibit unpredictable behavior. Modifying or adding new features to such code can have unintended consequences, causing unexpected issues or bugs throughout the application.

3. **Difficult to Grasp**: Jello can be challenging to handle, as it slips and slides. Similarly, code that is like jello may be difficult to understand or comprehend due to its lack of clarity and coherence. It may be challenging to determine how different parts of the code interact with each other, making it harder to troubleshoot and debug.

4. **Lack of Structure**: Jello lacks a solid structure and can easily change shape. When code is compared to jello, it suggests that the codebase lacks a well-defined architecture or design pattern. There may be little consistency in coding styles, naming conventions, or code organization, making it harder to navigate and maintain.

5. **Fragility**: Jello is delicate and can break apart easily. Similarly, code described as jello may be fragile, prone to errors, and susceptible to breaking when modifications are made. The lack of stability and structure can make it challenging to ensure the correctness and reliability of the application.

Describing application code as jello is often a critique, highlighting the need for improving code quality, structure, and stability. It suggests that the codebase requires refactoring, better organization, and adherence to software engineering best practices to enhance maintainability, predictability, and robustness.